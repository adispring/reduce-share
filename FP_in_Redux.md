# 函数式编程在 Redux 中的应用

## 复杂度以及抽象与组合

> 软件的首要技术使命是管理复杂度。 --代码大全

在软件开发的过程中，随着需求的变化和系统规模的增大，我们的软件不可避免的会变得复杂，如何对软件复杂度及其增长速度进行有效控制，便成为一个越来越突出的问题。

### 抽象

我们所处的整个世界的复杂性和多变性，而我们人类的大脑处理问题的能力相对是有限度的，比较“擅长”处理简单的事物。这就导致我们在认识世界的时候需要对整个世界做简化，将一般化和共性的事物和概念提取出来，形成理论和模型，进而指导我们对世界的改造，而简化的过程也即抽象的过程。

下面是关于抽象的一段描述：

> 心智的活动，特别擅长利用各种简单的认识，主要表现在如下三个方面：
> 1)将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。
> 2)将两个认识放在一起对照，不管它们简单或者复杂，由此得到有关它们的相互关系的认识。
> 3)将有关认识与那些在实际中和它们同在的所有其它认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。
>                                                 —— John Locke (有关人类理解的随笔 1690)

### 组合

如上面所提到的，在进行抽象的过程中，我们不自觉地用到了另一种方法：组合，通过简单认识的组合可以构造出复杂的认识（或概念）。或者反之，在面对复杂事物的处理，我们通常会将其拆分许多小而简单部分，分而治之，然后在将这些部分组合起来，整个问题也便得到了解决。

软件开发的过程，本质上也是人类认识和改造世界的一种活动，所以在软件开发中也需要借助抽象和组合来处理复杂的需求和任务。

在 《SICP》 中描述了一种好的程序设计语言应该具备的特性：

- **基本表达形式**，用于表示语言所关心的最简单的个体。
- **组合的方法**，通过它们可以从较简单的东西出发构造出构造出复合的元素。
- **抽象的方法**，通过它们可以为复合对象命名，并将它们当作单元去操作。

并规定了其需要处理的两类要素：函数（过程）和数据。

## 高阶函数作为抽象

一种功能强大的语言，需要能为公共的模式命名，建立抽象，然后直接在抽象的层次上工作。

如果函数只能以数值或对象为参数，将会严重限制人们建立抽象的能力。经常会有一些同样的设计模式能用于若干不同的过程。为了将这种模式描述为相应的概念，就需要构造出这样的函数，使其以函数作为参数，或者将函数作为返回值。这类能操作函数的函数成为高阶函数。

map、filter 和 reduce 作为操作序列的通用模式抽象了出来。可以通过向这三个抽象出来的高阶函数出入具体的函数，生成处理具体问题的函数；进一步，通过组合这些生成的具体的函数，几乎可以解决所有序列相关的问题。以 map 为例，其定义了一大类相似的序列的操作，即对序列中每个元素进行转换，至于如何转换，需要向 `map` 传入一个具体的转换函数进行具体化。这些抽象出来的高阶函数相当于具有某类功能的通用型机器，而传入的具体函数相当于特殊零件，通用机器配上具体零件就可以应用于属于该大类下的各种具体场景了。

`map` 的重要性不仅体现在它代表了一种公共的模式，还体现在它建立了一种处理序列的高层抽象。迭代操作将人们的注意力吸引到对于序列中逐个元素的处理上，引入 `map` 抑制了这种细节层面上的情况，强调的是从源序列到目标序列的变换。这两种定义形式之间的差异，并不在于计算机会执行不同的计算过程（其实不会），而在于我们对这个同一过程的不同思考方式。从作用上看，`map` 帮我们建立了一层抽象屏障，将序列转换的函数实现，与如何提取序列中元素以及组合结果的细节隔离开。这种抽象也提供了新的灵活性，使我们有可能在保持从序列到序列的变换操作框架的同时，改变序列实现的底层细节。

例如，我们有一个序列：

```js
const list = [1, 5, 7, 3]
```

若对序列中的每个元素加 1：

```js
map(a => a + 1, list)
```

若对序列中的每个元素平方：

```js
map(a => a * a, list)
```

我们只需向 `map` 传入具体的转换函数，`map` 便会自动将函数映射到序列的的每个元素。

再举一例，现在有一份公司所有人员的月度考核表，我们想统计所有到店餐饮部所有开发人员 7 月份完成的任务总数，假设每个员工每月绩效结构如下：

```js
{
  name: '张三',
  level: 'p2.1',
  segment: '到餐'
  tasks: 16,
  month: '201707',
  type: 'RD',
  ...
}
```

我们可以这样做：

```js
const tasksInJuly = compose(
  reduce(add, 0),
  map(person => person.tasks),
  filter(person => person.type === 'RD'),
  filter(person => person.segment === '到餐')
)
```

通过上例，我们可以看到利用高阶函数进行抽象和组合的强大和简洁之处。这种通用的模式（模块）+ "具体函数" 组合的模式，显示通用模块广泛适用范围和处理具体问题时的灵活性。

## 流

有上述过程我们又得到了一种新的模式，数据流。信号处理工程师可以很自然的用流过一些级联的处理模块的信号的方式来描述这一过程。我们输入公司全员月度考核信息作为信号，首先会流过两个过滤器，将所有不符合要求的数据过滤掉，这样得到的信号有通过一个映射，这是一个 "转换装置"，它从完整的员工对象转换为对应的任务信息。这一映射的输出被馈入一个累加器，该装置用 `add` 将所有的元素组合起来，以初始的 0 开始。

要组织好这些过程，最关键的是将注意力集中在处理过程中从一个步骤流向下一个步骤的 "信号"。如果我们用序列来表示这些信号，就可以利用序列操作实现每一步骤的处理。

或许因为序列操作太为常用，于是人们发明了一门专门处理序列的语言 Lisp（LISt Processor)。。。

将程序表示为针对序列的操作，这样做的价值就在于能帮助我们得到模块化的程序设计，也就是说，得到由一些比较独立的片段的组合构成的设计。通过提供一个标准部件的库，并使这些部件都有着一些能以各种灵活方式相互连接的约定接口，将能进一步推动人们去做模块化的设计。组合还需要一个关键性的性质，就是接下来要讲的闭包。

## 闭包

> 100 个函数操作一种数据结构的组合，要好过 10 个函数操作 10 中数据结构的组合。 -- Alan Perlis

"闭包" 来自与抽象代数，在抽象代数中，一个集合元素称为在某个运算（操作）之下是封闭的，如果将该运算应用于这一集合中的元素，产生出的仍然是该集合里的元素。（这与传统程序中的 ["闭包"](https://en.wikipedia.org/wiki/Closure_(computer_programming)) 概念是不同的）。

一般说，某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身还可以通过同样的操作在进行组合。闭包性质是任何一种组合功能的威力的关键要素，因为它是我们能够建立起层次性的结构，这种结构有一些部分构成，而其中的各个部分又是有他们的部分构成，并且可以如此继续下去。比如序列中的 `map`、`filter` 操作，React 中的高阶组件，Redux 中的高阶reducer，都满足闭包性质，因此都是可以组合的。

React 将 View 层提取出来，将其与具体的业务场景解耦，View = f(state)

Redux 将 state 从面向对象的模式转变成流模式 state = state(t)，增加了时间维度，[sicp p220] 

可以将 Redux 和 React 组合起来

React-Redux： View(t) = f(state(t)) = compose(f, state)(t) -> View(t) = compose(viewF, state)(t) -> View = compose(viewF, state)

抽象隐藏了具体实现的细节。

本文部分章节摘抄自《SICP》
